effect module HttpServer where { command = HttpCmd, subscription = HttpSub } exposing
    ( ServerError(..)
    , Request
    , Server
    , Method(..)
    , createServer
    , initialize
    , onRequest
    , toRequest
    , requestInfo
    , respond
    )


import Bytes exposing (Bytes)
import Dict exposing (Dict)
import Init
import Internal.Init
import Node
import Task exposing (Task)
import Gren.Kernel.HttpServer
import HttpServer.Response exposing (Response(..))
import Url exposing (Url, Protocol(..))


-- TODO: docs!
-- Preview with:
--   npm install -g gren-packages
--   gren-doc-preview


type Server
    -- Note: Actual implementation in Kernel code
    = Server


type alias Request =
    { headers : Dict String String
    , method : Method
    , body : Bytes
    , url : Url
    }


type Method
    = GET
    | HEAD
    | POST
    | PUT
    | DELETE
    | CONNECT
    | TRACE
    | PATCH
    | UNKNOWN


type Permission
    = Permission


{-| Errors from node http.server
    which inherits from net.server, see: <https://nodejs.org/api/net.html#event-error>
    The two strings will contain the error code and message respectively.
    Room for improvement here if we match on code and return more specific types.
-}
type ServerError =
    ServerError String String


initialize : Init.Task Permission
initialize =
    Task.succeed Permission
        |> Internal.Init.Task


createServer : Permission -> { host : String, port_ : Int } -> Task ServerError Server
createServer _ options =
    Gren.Kernel.HttpServer.createServer options.host options.port_


toRequest :
    { urlProtocol : String
    , urlHost : String
    , urlPort : String
    , urlPath : String
    , urlQuery : String
    , urlFragment : String
    , headers : Array String
    , method : String
    , body : Bytes
    }
    -> Request
toRequest 
    { urlProtocol
    , urlHost
    , urlPort
    , urlPath
    , urlQuery
    , urlFragment
    , headers
    , method
    , body 
    } =
    { method = toMethod method
    , body = body
    , headers =
        headers
            |> arrayPairs
            |> dictFromPairs
    , url =
        { protocol = 
            if urlProtocol == "https:" then
                Https
            else
                Http
        , host = urlHost
        , path = urlPath
        , port_ = String.toInt urlPort
        , query = 
            if urlQuery == "" then
                Nothing
            else
                Just urlQuery
        , fragment =
            if urlFragment == "" then
                Nothing
            else
                Just urlFragment
        }
    }


toMethod : String -> Method
toMethod s =
    case s of
        "GET" ->
            GET
        
        "HEAD" ->
            HEAD

        "POST" ->
            POST
        
        "PUT" ->
            PUT
        
        "DELETE" ->
            DELETE
        
        "CONNECT" ->
            CONNECT
        
        "TRACE" ->
            TRACE
        
        "PATCH" ->
            PATCH
        
        _ ->
            UNKNOWN


arrayPairs : Array String -> Array (Array String)
arrayPairs a =
    let
        pair = 
            Array.takeFirst 2 a
        
        rest =
            Array.dropFirst 2 a
        
        allPairs =
            [ pair ] ++ case rest of
                [] ->
                    []
                
                _ ->
                    arrayPairs rest
    in
    allPairs


dictFromPairs : Array (Array String) -> Dict String String
dictFromPairs pairs =
    let
        mapper p =
            case p of
                [a, b] ->
                    Just { key = a, value = b }
                
                _ ->
                    Nothing
        
        array =
            Array.filterMap mapper pairs
    in
    Dict.fromArray array


-- EFFECT STUFF


type HttpCmd a
    = SendResponse Response


type HttpSub msg
    = OnRequestSub Server (Request -> Response -> msg)


cmdMap : (a -> b) -> HttpCmd a -> HttpCmd b
cmdMap _ cmd =
    case cmd of
        SendResponse r ->
            SendResponse r


subMap : (a -> b) -> HttpSub a -> HttpSub b
subMap f sub =
    case sub of
        OnRequestSub server msg ->
            -- TODO: not sure this is right
            OnRequestSub server (\req res -> f (msg req res))


type alias State msg =
    Array (HttpSub msg)


init : Task Never (State msg)
init =
    Task.succeed []


onEffects
    : Platform.Router msg SelfMsg
    -> Array (HttpCmd a)
    -> Array (HttpSub msg)
    -> State msg
    -> Task Never (State msg)
onEffects router cmds subs state =
    let
        -- TODO: look at Termina.gren for a better way to manage subscriptions
        -- For now just removing them all then re-adding.
        _removeListeners =
            state
                |> Array.map
                    (\(OnRequestSub server _) ->
                        Gren.Kernel.HttpServer.removeAllListeners server
                    )
        
        _addListeners =
            subs
                |> Array.map
                    (\(OnRequestSub server msg) ->
                        Gren.Kernel.HttpServer.addListener server router msg
                    )

        _sendResponses =
            cmds
                |> Array.map
                    (\(SendResponse (Response kernelResponse response)) ->
                        -- Terminal.gren sends to self and makes the kernel calls in onSelfMsg,
                        -- but I couldn't get a self msg to trigger onSelfMsg when I tried that.
                        Gren.Kernel.HttpServer.setStatus response.status kernelResponse
                            |> Gren.Kernel.HttpServer.setHeaders (Dict.toArray response.headers)
                            |> Gren.Kernel.HttpServer.setBody response.body
                            |> Gren.Kernel.HttpServer.endResponse
                    )
    in
    Task.succeed subs


type SelfMsg =
    Never


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> (State msg) -> Task Never (State msg)
onSelfMsg _ _ state =
    Task.succeed state


onRequest : Server -> (Request -> Response -> msg) -> Sub msg
onRequest server tagger =
    subscription (OnRequestSub server tagger)


requestInfo : Request -> String
requestInfo req =
    let
        method
            = case req.method of
                GET ->
                    "GET"

                HEAD ->
                    "HEAD"

                POST ->
                    "POST"

                PUT ->
                    "PUT"

                DELETE ->
                    "DELETE"

                CONNECT ->
                    "CONNECT"

                TRACE ->
                    "TRACE"

                PATCH ->
                    "PATCH"

                UNKNOWN ->
                    "UNKNOWN"
    in
    method ++ " " ++ req.url.path


respond : Response -> Cmd a
respond response =
    command (SendResponse response)
