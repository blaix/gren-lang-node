module FileSystem exposing
    ( Permission
    , initialize
    --
    , FileHandle
    , ReadableFileHandle
    , WriteableFileHandle
    , ReadWriteableFileHandle
    --
    , UnknownFileSystemError(..)
    , AccessError(..)
    --
    , openForRead
    , OpenForWriteBehaviour
    , openForWrite
    , openForReadAndWrite
    , close
    --
    , read
    , readFromOffset
    --
    , write
    , writeFromOffset
    --
    , RemoveOptions
    , remove
    --
    , makeDirectory
    , listDirectoryContent
    )


{-| Let's you manipulate the file system.

## Initialization

@docs Permission, initialize

## Errors

@docs AccessError, UnknownFileSystemError

## File open/close

@docs FileHandle, ReadableFileHandle, WriteableFileHandle, ReadWriteableFileHandle, openForRead, OpenForWriteBehaviour, openForWrite, openForReadAndWrite, close

## Read from file

@docs read, readFromOffset

## Write to file

@docs write, writeFromOffset

## Remove files and directories

@docs RemoveOptions, remove

## Directories

@docs makeDirectory, listDirectoryContent
-}


import Gren.Kernel.FileSystem
import Bytes exposing (Bytes)
import Task exposing (Task)
import Node.Program as Program
import Internal.AppInitTask exposing (AppInitTask(..))


{-| This value represents the permission to perform file system operations.

Only code you trust should have access to this value.
-}
type Permission
    = Permission


{-| Initialize the `FileSystem` subsystem, which gains you the permission to perform
file system operations.
-}
initialize : Program.AppInitTask Permission
initialize =
    Task.succeed Permission
        |> AppInitTask


-- FILES


{-| A file handle is used to perform operations on a file, like reading and writing.

Having a file handle gives you access to perform certain operations, so make sure you
only pass a file handle to code you can trust.

The `FileHandle` type also contains the read and write access permissions as part of it's
type.
-}
type FileHandle readAccess writeAccess
    -- Note: Actual implementation in kernel code
    = FileHandle


type ReadPermission = ReadPermission
type NoReadPermission = NoReadPermission

type WritePermission = WritePermission
type NoWritePermission = NoWritePermission


{-| A `FileHandle` that can be used in read operations.
-}
type alias ReadableFileHandle a = FileHandle ReadPermission a


{-| A `FileHandle` that can be used in write operations.
-}
type alias WriteableFileHandle a = FileHandle a WritePermission


{-| A `FileHandle` that can be used for both read and write operations.
-}
type alias ReadWriteableFileHandle = FileHandle ReadPermission WritePermission


-- ERRORS


{-| The set of errors that can happen when accessing a file or directory.
-}
type AccessError
    = AccessErrorNotFound
    | AccessErrorNoAccess
    | AccessErrorUnknown String


{-| An error thrown by the OS, in situations where we don't expect errors to happen,
or have been unable to reproduce such an error in development.
-}
type UnknownFileSystemError
    = UnknownFileSystemError String


-- OPEN


{-| Open the file at the provided path with read permissions.
-}
openForRead : Permission -> String -> Task AccessError (ReadableFileHandle a)
openForRead _ path =
    openImpl "r" path


{-| There are several ways to open a file for writing.

* `EnsureEmpty` will create an empty file if it doesn't exist, or remove all contents of a file if it does exist.
* `ExpectExisting` will fail the task if it doesn't exist.
* `ExpectNotExisting` will fail the task if the file does exist.
-}
type OpenForWriteBehaviour
    = EnsureEmpty
    | ExpectExisting
    | ExpectNotExisting


{-| Open a file at the provided path with write permissions.
-}
openForWrite : Permission -> OpenForWriteBehaviour -> String -> Task AccessError (WriteableFileHandle a)
openForWrite _ behaviour path =
    let
        access =
            case behaviour of
                EnsureEmpty -> "w"
                ExpectExisting -> "r+"
                ExpectNotExisting -> "wx"
    in
    openImpl access path


{-| Open a file for at the provided path with both read and write permissions.
-}
openForReadAndWrite : Permission -> OpenForWriteBehaviour -> String -> Task AccessError ReadWriteableFileHandle
openForReadAndWrite _ behaviour path =
    let
        access =
            case behaviour of
                EnsureEmpty -> "w+"
                ExpectExisting -> "r+"
                ExpectNotExisting -> "wx+"
    in
    openImpl access path


openImpl : String -> String -> Task AccessError (FileHandle a b)
openImpl =
    Gren.Kernel.FileSystem.open


-- CLOSE

{-| Close a file. All operations performed against the given `FileHandle` will fail.
-}
close : FileHandle a b -> Task UnknownFileSystemError {}
close =
    Gren.Kernel.FileSystem.close


-- READING


{-| Read all bytes in a file.
-}
read : ReadableFileHandle a -> Task UnknownFileSystemError Bytes
read fh =
    readFromOffset fh { offset = 0, length = -1 }


{-| Read `length` number of bytes from a file, starting at `offset` bytes.
-}
readFromOffset : ReadableFileHandle a -> { offset : Int, length : Int } -> Task UnknownFileSystemError Bytes
readFromOffset =
    Gren.Kernel.FileSystem.readFromOffset


-- WRITING


{-| Write the provided bytes into the file. If the file is not empty, bytes will be overwritten.
-}
write : WriteableFileHandle a -> Bytes -> Task UnknownFileSystemError {}
write fh bytes =
    writeFromOffset fh 0 bytes


{-| Write bytes into a specific location of a file.
-}
writeFromOffset : WriteableFileHandle a -> Int -> Bytes -> Task UnknownFileSystemError {}
writeFromOffset =
    Gren.Kernel.FileSystem.writeFromOffset


-- REMOVE


{-| This record allows you to customize the behaviour of `remove`.

* `recursive` will delete everything inside a directory.
* `ignoreErrors` will... ignore any errors related to a remove operation.
-}
type alias RemoveOptions =
    { recursive : Bool
    , ignoreErrors : Bool
    }


{-| Remove the file or directory at the given path.
-}
remove : Permission -> String -> RemoveOptions -> Task AccessError {}
remove _ path options =
    Gren.Kernel.FileSystem.remove options path


-- DIRECTORIES


{-| Create a new directory at the given path.

If `recursive` is `True`, then a directory will be created for every section of the
given path.
-}
makeDirectory : Permission -> String -> { recursive : Bool } -> Task AccessError {}
makeDirectory _ path options =
    Gren.Kernel.FileSystem.makeDirectory options path


{-| Returns an `Array` of `String` containing the content names of the directory at the
given path.
-}
listDirectoryContent : Permission -> String -> Task AccessError (Array String)
listDirectoryContent _ path =
    Gren.Kernel.FileSystem.listDirectoryContent path
