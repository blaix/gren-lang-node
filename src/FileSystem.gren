effect module FileSystem where { subscription = FileSystemSub } exposing
    ( Permission
    , initialize
    -- Errors
    , AccessError(..)
    , accessErrorToString
    , UnknownFileSystemError(..)
    , unknownFileSystemErrorToString
    -- Metadata
    , Metadata
    , EntityType(..)
    , metadata
    , AccessPermission(..)
    , checkAccess
    , changeAccess
    , accessPermissionsToInt
    , changeOwner
    , changeTimes
    , rename
    , realPath
    -- Files
    , appendToFile
    , copyFile
    , readFile
    , writeFile
    , truncateFile
    , remove
    -- Directories
    , listDirectory
    , makeDirectory
    , makeTempDirectory
    , currentWorkingDirectory
    -- Links
    , hardLink
    , softLink
    , readLink
    , unlink
    -- Watch
    , WatchEvent(..)
    , watch
    , watchRecursive
    )


{-| This module provides access to the file system. It allows you to read and write files or directories.

## Initialization

@docs Permission, initialize

## Errors

@docs AccessError, accessErrorToString, UnknownFileSystemError, unknownFileSystemErrorToString

## Metadata

@docs Metadata, EntityType, metadata, AccessPermission, checkAccess, changeAccess, accessPermissionsToInt, changeOwner, changeTimes, rename, realPath

## Files

@docs copyFile, appendToFile, readFile, writeFile, truncateFile, remove

## Directories

@docs listDirectory, makeDirectory, makeTempDirectory, currentWorkingDirectory

## Links

@docs hardLink, softLink, readLink, unlink

-}


import Gren.Kernel.FileSystem
import Gren.Kernel.FilePath
import Bytes exposing (Bytes)
import Dict exposing (Dict)
import Task exposing (Task)
import FileSystem.Path exposing (Path)
import Init
import Internal.Init
import Time
import Process


{-| This value represents the permission to perform file system operations.

Only code you trust should have access to this value.
-}
type Permission
    = Permission


{-| Initialize the `FileSystem` subsystem, which gains you the permission to perform
file system operations.
-}
initialize : Init.Task Permission
initialize =
    Task.succeed Permission
        |> Internal.Init.Task


-- ERRORS


{-| The set of errors that can happen when accessing a file or directory.
-}
type AccessError
    = AccessErrorNotFound
    | AccessErrorNoAccess
    | AccessErrorNotADirectory
    | AccessErrorUnknown String


accessErrorToString : AccessError -> String
accessErrorToString err =
    case err of
        AccessErrorNotFound -> "Not found"
        AccessErrorNoAccess -> "No access"
        AccessErrorNotADirectory -> "Not a directory"
        AccessErrorUnknown errorMessage -> "Unknown error: " ++ errorMessage


{-| An error thrown by the OS, in situations where we don't expect errors to happen,
or have been unable to reproduce such an error in development.
-}
type UnknownFileSystemError
    = UnknownFileSystemError String


unknownFileSystemErrorToString : UnknownFileSystemError -> String
unknownFileSystemErrorToString (UnknownFileSystemError msg) =
    msg


-- METADATA


type alias Metadata =
    { entityType : EntityType
    , deviceID : Int
    , userID : Int
    , groupID : Int
    , byteSize : Int
    , blockSize : Int
    , blocks : Int
    , lastAccessed : Time.Posix
    , lastModified : Time.Posix
    , lastChanged : Time.Posix
    , created : Time.Posix
    }


{-| Represents entries in a directory.

Variants for each type of entry, with a `String` representing the relative path.
-}
type EntityType
    = File
    | Directory
    | Socket
    | Symlink
    | Device
    | Pipe


metadata : Permission -> { resolveLink : Bool } -> Path -> Task AccessError Metadata
metadata _ { resolveLink } path =
    if resolveLink then
        Gren.Kernel.FileSystem.stat path

    else
        Gren.Kernel.FileSystem.lstat path


type AccessPermission
    = Read
    | Write
    | Execute


checkAccess : Permission -> Array AccessPermission -> Path -> Task AccessError Path
checkAccess _ permissions path =
    Gren.Kernel.FileSystem.access permissions path


changeAccess 
    : Permission
    -> { owner : Array AccessPermission 
       , group : Array AccessPermission
       , others : Array AccessPermission
       , resolveLink : Bool
       }
    -> Path
    -> Task AccessError Path
changeAccess _ permissions path =
    let
        mode =
            (String.fromInt <| accessPermissionsToInt permissions.owner)
            ++ (String.fromInt <| accessPermissionsToInt permissions.group)
            ++ (String.fromInt <| accessPermissionsToInt permissions.others)
    in
    if permissions.resolveLink then
        Gren.Kernel.FileSystem.chmod mode path

    else
        Gren.Kernel.FileSystem.lchmod mode path


accessPermissionsToInt : Array AccessPermission -> Int
accessPermissionsToInt values =
    let
        numberFor num a =
            if Array.member a values then
                num

            else
                0
    in
    numberFor 4 Read + numberFor 2 Write + numberFor 1 Execute


changeOwner : Permission -> { userID : Int, groupID : Int, resolveLink : Bool } -> Path -> Task AccessError Path
changeOwner _ options path =
    if options.resolveLink then
        Gren.Kernel.FileSystem.chown options path

    else
        Gren.Kernel.FileSystem.lchown options path


changeTimes : Permission -> { lastAccessed : Time.Posix, lastModified : Time.Posix, resolveLink : Bool } -> Path -> Task AccessError Path
changeTimes _ { lastAccessed, lastModified, resolveLink } path =
    let
        lastAccessedSeconds = 
            Time.posixToMillis lastAccessed // 1000
        
        lastModifiedSeconds = 
            Time.posixToMillis lastModified // 1000
    in
    if resolveLink then
        Gren.Kernel.FileSystem.utimes lastAccessedSeconds lastModifiedSeconds path

    else
        Gren.Kernel.FileSystem.lutimes lastAccessedSeconds lastModifiedSeconds path


rename : Permission -> Path -> Path -> Task AccessError Path
rename _ new old =
    Gren.Kernel.FileSystem.rename old new


realPath : Permission -> Path -> Task AccessError Path
realPath _ path =
    Gren.Kernel.FileSystem.realpath path


-- FILES


appendToFile : Permission -> Bytes -> Path -> Task AccessError Path
appendToFile _ bytes path =
    Gren.Kernel.FileSystem.appendFile bytes path


copyFile : Permission -> Path -> Path -> Task AccessError Path
copyFile _ dest src =
    Gren.Kernel.FileSystem.copyFile src dest


readFile : Permission -> Path -> Task AccessError Bytes
readFile _ path =
    Gren.Kernel.FileSystem.readFile path


writeFile : Permission -> Bytes -> Path -> Task AccessError Path
writeFile _ bytes path =
    Gren.Kernel.FileSystem.writeFile bytes path


truncateFile : Permission -> Int -> Path -> Task AccessError Path
truncateFile _ length path =
    Gren.Kernel.FileSystem.truncate length path


{-| Remove the file or directory at the given path.

* `recursive` will delete everything inside a directory.
* `ignoreErrors` will... ignore any errors related to a remove operation.
-}
remove : Permission -> { recursive : Bool, ignoreErrors : Bool } -> Path -> Task AccessError Path
remove _ options path =
    Gren.Kernel.FileSystem.remove options path


-- DIRECTORIES


{-| Returns an `Array` of `DirEntry` variants holding names of the files in the
directory at the given path.
-}
listDirectory : Permission -> Path -> Task AccessError (Array { path : Path, entityType : EntityType })
listDirectory _ path =
    Gren.Kernel.FileSystem.listDirectory path


{-| Create a new directory at the given path.

If `recursive` is `True`, then a directory will be created for every section of the
given path.
-}
makeDirectory : Permission -> { recursive : Bool } -> Path -> Task AccessError Path
makeDirectory _ options path =
    Gren.Kernel.FileSystem.makeDirectory options path


makeTempDirectory : Permission -> String -> Task AccessError Path
makeTempDirectory _ prefix =
    Gren.Kernel.FileSystem.mkdtemp prefix


{-| Returns the current working directory of the program.
This is the directory that all relative paths are relative to.
-}
currentWorkingDirectory : Permission -> Task x Path
currentWorkingDirectory _ =
    Gren.Kernel.FileSystem.currentWorkingDirectory


-- LINKS


hardLink : Permission -> Path -> Path -> Task AccessError Path
hardLink _ dest src =
    Gren.Kernel.FileSystem.link src dest


softLink : Permission -> Path -> Path -> Task AccessError Path
softLink _ dest src =
    Gren.Kernel.FileSystem.symlink src dest


readLink : Permission -> Path -> Task AccessError Path
readLink _ path =
    Gren.Kernel.FileSystem.readLink path


unlink : Permission -> Path -> Task AccessError Path
unlink _ path =
    Gren.Kernel.FileSystem.unlink path


-- SUBSCRIPTION


type FileSystemSub msg
    = Watch Path Bool (WatchEvent -> msg)


type WatchEvent
    = Changed (Maybe Path)
    | Moved (Maybe Path)


subMap : (a -> b) -> FileSystemSub a -> FileSystemSub b
subMap mapFn sub =
    case sub of
        Watch path recursive msgMap ->
            Watch path recursive (mapFn << msgMap)


{-| This notifies your application every time bytes have arrived over the `Stream`.
-}
watch : Permission -> (WatchEvent -> msg) -> Path -> Sub msg
watch _ msgMap path =
    subscription (Watch path False msgMap)


{-| This notifies your application every time bytes have arrived over the `Stream`.
-}
watchRecursive : Permission -> (WatchEvent -> msg) -> Path -> Sub msg
watchRecursive _ msgMap path =
    subscription (Watch path True msgMap)


-- LOOP


type alias State msg =
    { watchers : Dict String (Taggers msg)
    , recursiveWatchers : Dict String (Taggers msg)
    , processes : Dict String Process.Id
    }


type alias Taggers msg =
    Array (WatchEvent -> msg)


init : Task Never (State msg)
init =
    Task.succeed
        { watchers = Dict.empty
        , recursiveWatchers = Dict.empty
        , processes = Dict.empty
        }


onEffects
    : Platform.Router msg SelfMsg
    -> Array (FileSystemSub msg)
    -> State msg
    -> Task.Task Never (State msg)
onEffects router subs state =
    let
        newWatchers =
            subs
                |> Array.filter (\(Watch _ bool _) -> not bool)
                |> Array.foldl subToWatcher Dict.empty

        newRecursiveWatchers =
            subs
                |> Array.filter (\(Watch _ bool _) -> bool)
                |> Array.foldl subToWatcher Dict.empty

        toSpawn =
            Dict.diff newWatchers state.watchers
                |> Dict.keys
        
        recursiveToSpawn =
            Dict.diff newRecursiveWatchers state.recursiveWatchers
                |> Dict.keys
        
        toStop =
            Dict.diff state.watchers newWatchers
                |> Dict.keys
        
        recursiveToStop =
            Dict.diff state.recursiveWatchers newRecursiveWatchers
                |> Dict.keys

        asRecursiveKey key =
            key ++ "$recursive"

        flipFold fn array initial =
            Array.foldl fn initial array

        taskStopper keyMapper =
            (\key accTask ->
                Task.andThen 
                    (\processes ->
                        let
                            realKey = 
                                keyMapper key
                        in
                        case Dict.get realKey processes of
                            Just processId ->
                                Process.kill processId
                                    |> Task.map (\_ -> Dict.remove realKey processes)

                            Nothing ->
                                accTask
                    )
                    accTask
            )

        taskSpawner keyMapper isRecursive =
            (\key accTask ->
                accTask
                    |> Task.andThen 
                        (\processes ->
                            Process.spawn (attachWatcher key isRecursive (Platform.sendToSelf router << WatchPathChange isRecursive key))
                                |> Task.map (\id -> Dict.insert (keyMapper key) id processes)
                        )
            )
    in
    Array.foldl 
        (taskStopper identity)
        (Task.succeed state.processes)
        toStop
    |> flipFold (taskStopper asRecursiveKey) recursiveToStop
    |> flipFold (taskSpawner identity False) toSpawn
    |> flipFold (taskSpawner asRecursiveKey True) recursiveToSpawn
    |> Task.map
        (\newProcesses ->
            { watchers = newWatchers
            , recursiveWatchers = newRecursiveWatchers
            , processes = newProcesses
            }
        )


subToWatcher : FileSystemSub msg -> Dict String (Taggers msg) -> Dict String (Taggers msg)
subToWatcher sub taggers =
    case sub of
        Watch path _ tagger ->
            let
                key =
                    Gren.Kernel.FilePath.toString path
            in
            case Dict.get key taggers of
                Just data ->
                    Dict.insert 
                        key
                        (Array.pushLast tagger data)
                        taggers

                Nothing ->
                    Dict.insert key [ tagger ] taggers


attachWatcher : String -> Bool -> (WatchEvent -> Task.Task Never {}) -> Task.Task x {}
attachWatcher =
  Gren.Kernel.FileSystem.watch


type SelfMsg
    = WatchPathChange Bool String WatchEvent


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> State msg -> Task.Task Never (State msg)
onSelfMsg router (WatchPathChange recursive key event) state =
    let
        notifyApplication taggers =
            Array.foldl 
                (\tagger tasks -> 
                    tasks
                        |> Task.andThen (\{} -> Platform.sendToApp router (tagger event))
                )
                (Task.succeed {})
                taggers
                |> Task.map (\{} -> state)
    in
    if recursive then
        case Dict.get key state.recursiveWatchers of
            Just taggers ->
                notifyApplication taggers

            Nothing ->
                Task.succeed state

    else
        case Dict.get key state.watchers of
            Just taggers ->
                notifyApplication taggers

            Nothing ->
                Task.succeed state
