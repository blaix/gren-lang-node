effect module FileSystem where { subscription = FileSystemSub } exposing
    ( Permission
    , initialize
    -- Errors
    , Error
    , errorCode
    , errorToString
    , errorIsPermissionDenied
    , errorIsFileExists
    , errorIsDirectoryFound
    , errorIsTooManyOpenFiles
    , errorIsNoSuchFileOrDirectory
    , errorIsNotADirectory
    , errorIsDirectoryNotEmpty
    , errorIsNotPermitted
    , errorIsLinkLoop
    , errorIsPathTooLong
    , errorIsInvalidInput
    , errorIsIO
    -- Metadata
    , Metadata
    , EntityType(..)
    , metadata
    , AccessPermission(..)
    , checkAccess
    , changeAccess
    , accessPermissionsToInt
    , changeOwner
    , changeTimes
    , move
    , realPath
    -- Files
    , appendToFile
    , copyFile
    , readFile
    , writeFile
    , truncateFile
    , remove
    -- Directories
    , listDirectory
    , makeDirectory
    , makeTempDirectory
    -- Links
    , hardLink
    , softLink
    , readLink
    , unlink
    -- Watch
    , WatchEvent(..)
    , watch
    , watchRecursive
    )


{-| This module provides access to the file system. It allows you to read and write files or directories.

## Initialization

@docs Permission, initialize

## Errors

@docs Error, errorCode, errorToString
@docs errorIsPermissionDenied, errorIsFileExists, errorIsDirectoryFound, errorIsTooManyOpenFiles, errorIsNoSuchFileOrDirectory, errorIsNotADirectory, errorIsDirectoryNotEmpty, errorIsNotPermitted, errorIsLinkLoop, errorIsPathTooLong, errorIsInvalidInput, errorIsIO

## Metadata

@docs Metadata, EntityType, metadata, AccessPermission, checkAccess, changeAccess, accessPermissionsToInt, changeOwner, changeTimes, move, realPath

## Files

@docs copyFile, appendToFile, readFile, writeFile, truncateFile, remove

## Directories

@docs listDirectory, makeDirectory, makeTempDirectory 

## Links

@docs hardLink, softLink, readLink, unlink

## Watch for changes

@docs WatchEvent, watch, watchRecursive

-}


import Gren.Kernel.FileSystem
import Gren.Kernel.FilePath
import Bytes exposing (Bytes)
import Dict exposing (Dict)
import Task exposing (Task)
import FileSystem.Path exposing (Path)
import Init
import Internal.Init
import Time
import Process


{-| This value represents the permission to perform file system operations.

Only code you trust should have access to this value.
-}
type Permission
    = Permission


{-| Initialize the `FileSystem` subsystem, which gains you the permission to perform
file system operations.
-}
initialize : Init.Task Permission
initialize =
    Task.succeed Permission
        |> Internal.Init.Task


-- ERRORS


{-| The set of errors that can happen when accessing a file or directory.
-}
type Error
    = Error String String


{-|
-}
errorCode : Error -> String
errorCode (Error code _) =
    code


{-|
-}
errorToString : Error -> String
errorToString (Error _ message) =
    message


{-|
-}
errorIsPermissionDenied : Error -> Bool
errorIsPermissionDenied (Error code _) =
    code == "EACCES"


{-|
-}
errorIsFileExists : Error -> Bool
errorIsFileExists (Error code _) =
    code == "EEXIST"


{-|
-}
errorIsDirectoryFound : Error -> Bool
errorIsDirectoryFound (Error code _) =
    code == "EISDIR"


{-|
-}
errorIsTooManyOpenFiles : Error -> Bool
errorIsTooManyOpenFiles (Error code _) =
    code == "EMFILE"


{-|
-}
errorIsNoSuchFileOrDirectory : Error -> Bool
errorIsNoSuchFileOrDirectory (Error code _) =
    code == "ENOENT"


{-|
-}
errorIsNotADirectory : Error -> Bool
errorIsNotADirectory (Error code _) =
    code == "ENOTDIR"


{-|
-}
errorIsDirectoryNotEmpty : Error -> Bool
errorIsDirectoryNotEmpty (Error code _) =
    code == "ENOTEMPTY"


{-|
-}
errorIsNotPermitted : Error -> Bool
errorIsNotPermitted (Error code _) =
    code == "EPERM"


{-|
-}
errorIsLinkLoop : Error -> Bool
errorIsLinkLoop (Error code _) =
    code == "ELOOP"


{-|
-}
errorIsPathTooLong : Error -> Bool
errorIsPathTooLong (Error code _) =
    code == "ENAMETOOLONG"


{-|
-}
errorIsInvalidInput : Error -> Bool
errorIsInvalidInput (Error code _) =
    code == "EINVAL"


{-|
-}
errorIsIO : Error -> Bool
errorIsIO (Error code _) =
    code == "EIO"


-- METADATA


{-|
-}
type alias Metadata =
    { entityType : EntityType
    , deviceID : Int
    , userID : Int
    , groupID : Int
    , byteSize : Int
    , blockSize : Int
    , blocks : Int
    , lastAccessed : Time.Posix
    , lastModified : Time.Posix
    , lastChanged : Time.Posix
    , created : Time.Posix
    }


{-| Represents entries in a directory.

Variants for each type of entry, with a `String` representing the relative path.
-}
type EntityType
    = File
    | Directory
    | Socket
    | Symlink
    | Device
    | Pipe


{-|
-}
metadata : Permission -> { resolveLink : Bool } -> Path -> Task Error Metadata
metadata _ { resolveLink } path =
    if resolveLink then
        Gren.Kernel.FileSystem.stat path

    else
        Gren.Kernel.FileSystem.lstat path


{-|
-}
type AccessPermission
    = Read
    | Write
    | Execute


{-|
-}
checkAccess : Permission -> Array AccessPermission -> Path -> Task Error Path
checkAccess _ permissions path =
    Gren.Kernel.FileSystem.access permissions path


{-|
-}
changeAccess 
    : Permission
    -> { owner : Array AccessPermission 
       , group : Array AccessPermission
       , others : Array AccessPermission
       , resolveLink : Bool
       }
    -> Path
    -> Task Error Path
changeAccess _ permissions path =
    let
        mode =
            (String.fromInt <| accessPermissionsToInt permissions.owner)
            ++ (String.fromInt <| accessPermissionsToInt permissions.group)
            ++ (String.fromInt <| accessPermissionsToInt permissions.others)
    in
    if permissions.resolveLink then
        Gren.Kernel.FileSystem.chmod mode path

    else
        Gren.Kernel.FileSystem.lchmod mode path


{-|
-}
accessPermissionsToInt : Array AccessPermission -> Int
accessPermissionsToInt values =
    let
        numberFor num a =
            if Array.member a values then
                num

            else
                0
    in
    numberFor 4 Read + numberFor 2 Write + numberFor 1 Execute


{-|
-}
changeOwner : Permission -> { userID : Int, groupID : Int, resolveLink : Bool } -> Path -> Task Error Path
changeOwner _ options path =
    if options.resolveLink then
        Gren.Kernel.FileSystem.chown options path

    else
        Gren.Kernel.FileSystem.lchown options path


{-|
-}
changeTimes : Permission -> { lastAccessed : Time.Posix, lastModified : Time.Posix, resolveLink : Bool } -> Path -> Task Error Path
changeTimes _ { lastAccessed, lastModified, resolveLink } path =
    let
        lastAccessedSeconds = 
            Time.posixToMillis lastAccessed // 1000
        
        lastModifiedSeconds = 
            Time.posixToMillis lastModified // 1000
    in
    if resolveLink then
        Gren.Kernel.FileSystem.utimes lastAccessedSeconds lastModifiedSeconds path

    else
        Gren.Kernel.FileSystem.lutimes lastAccessedSeconds lastModifiedSeconds path


{-|
-}
move : Permission -> Path -> Path -> Task Error Path
move _ new old =
    Gren.Kernel.FileSystem.rename old new


{-|
-}
realPath : Permission -> Path -> Task Error Path
realPath _ path =
    Gren.Kernel.FileSystem.realpath path


-- FILES


{-|
-}
appendToFile : Permission -> Bytes -> Path -> Task Error Path
appendToFile _ bytes path =
    Gren.Kernel.FileSystem.appendFile bytes path


{-|
-}
copyFile : Permission -> Path -> Path -> Task Error Path
copyFile _ dest src =
    Gren.Kernel.FileSystem.copyFile src dest


{-|
-}
readFile : Permission -> Path -> Task Error Bytes
readFile _ path =
    Gren.Kernel.FileSystem.readFile path


{-|
-}
writeFile : Permission -> Bytes -> Path -> Task Error Path
writeFile _ bytes path =
    Gren.Kernel.FileSystem.writeFile bytes path


{-|
-}
truncateFile : Permission -> Int -> Path -> Task Error Path
truncateFile _ length path =
    Gren.Kernel.FileSystem.truncate length path


{-| Remove the file or directory at the given path.

* `recursive` will delete everything inside a directory.
* `ignoreErrors` will... ignore any errors related to a remove operation.
-}
remove : Permission -> { recursive : Bool, ignoreErrors : Bool } -> Path -> Task Error Path
remove _ options path =
    Gren.Kernel.FileSystem.remove options path


-- DIRECTORIES


{-| Returns an `Array` of `DirEntry` variants holding names of the files in the
directory at the given path.
-}
listDirectory : Permission -> Path -> Task Error (Array { path : Path, entityType : EntityType })
listDirectory _ path =
    Gren.Kernel.FileSystem.listDirectory path


{-| Create a new directory at the given path.

If `recursive` is `True`, then a directory will be created for every section of the
given path.
-}
makeDirectory : Permission -> { recursive : Bool } -> Path -> Task Error Path
makeDirectory _ options path =
    Gren.Kernel.FileSystem.makeDirectory options path


{-|
-}
makeTempDirectory : Permission -> String -> Task Error Path
makeTempDirectory _ prefix =
    Gren.Kernel.FileSystem.mkdtemp prefix


-- LINKS


{-|
-}
hardLink : Permission -> Path -> Path -> Task Error Path
hardLink _ dest src =
    Gren.Kernel.FileSystem.link src dest


{-|
-}
softLink : Permission -> Path -> Path -> Task Error Path
softLink _ dest src =
    Gren.Kernel.FileSystem.symlink src dest


{-|
-}
readLink : Permission -> Path -> Task Error Path
readLink _ path =
    Gren.Kernel.FileSystem.readLink path


{-|
-}
unlink : Permission -> Path -> Task Error Path
unlink _ path =
    Gren.Kernel.FileSystem.unlink path


-- SUBSCRIPTION


type FileSystemSub msg
    = Watch Path Bool (WatchEvent -> msg)


{-|
-}
type WatchEvent
    = Changed (Maybe Path)
    | Moved (Maybe Path)


subMap : (a -> b) -> FileSystemSub a -> FileSystemSub b
subMap mapFn sub =
    case sub of
        Watch path recursive msgMap ->
            Watch path recursive (mapFn << msgMap)


{-| This notifies your application every time bytes have arrived over the `Stream`.
-}
watch : Permission -> (WatchEvent -> msg) -> Path -> Sub msg
watch _ msgMap path =
    subscription (Watch path False msgMap)


{-| This notifies your application every time bytes have arrived over the `Stream`.
-}
watchRecursive : Permission -> (WatchEvent -> msg) -> Path -> Sub msg
watchRecursive _ msgMap path =
    subscription (Watch path True msgMap)


-- LOOP


type alias State msg =
    { watchers : Dict String (Taggers msg)
    , recursiveWatchers : Dict String (Taggers msg)
    , processes : Dict String Process.Id
    }


type alias Taggers msg =
    Array (WatchEvent -> msg)


init : Task Never (State msg)
init =
    Task.succeed
        { watchers = Dict.empty
        , recursiveWatchers = Dict.empty
        , processes = Dict.empty
        }


onEffects
    : Platform.Router msg SelfMsg
    -> Array (FileSystemSub msg)
    -> State msg
    -> Task.Task Never (State msg)
onEffects router subs state =
    let
        newWatchers =
            subs
                |> Array.filter (\(Watch _ bool _) -> not bool)
                |> Array.foldl subToWatcher Dict.empty

        newRecursiveWatchers =
            subs
                |> Array.filter (\(Watch _ bool _) -> bool)
                |> Array.foldl subToWatcher Dict.empty

        toSpawn =
            Dict.diff newWatchers state.watchers
                |> Dict.keys
        
        recursiveToSpawn =
            Dict.diff newRecursiveWatchers state.recursiveWatchers
                |> Dict.keys
        
        toStop =
            Dict.diff state.watchers newWatchers
                |> Dict.keys
        
        recursiveToStop =
            Dict.diff state.recursiveWatchers newRecursiveWatchers
                |> Dict.keys

        asRecursiveKey key =
            key ++ "$recursive"

        flipFold fn array initial =
            Array.foldl fn initial array

        taskStopper keyMapper =
            (\key accTask ->
                Task.andThen 
                    (\processes ->
                        let
                            realKey = 
                                keyMapper key
                        in
                        case Dict.get realKey processes of
                            Just processId ->
                                Process.kill processId
                                    |> Task.map (\_ -> Dict.remove realKey processes)

                            Nothing ->
                                accTask
                    )
                    accTask
            )

        taskSpawner keyMapper isRecursive =
            (\key accTask ->
                accTask
                    |> Task.andThen 
                        (\processes ->
                            Process.spawn (attachWatcher key isRecursive (Platform.sendToSelf router << WatchPathChange isRecursive key))
                                |> Task.map (\id -> Dict.set (keyMapper key) id processes)
                        )
            )
    in
    Array.foldl 
        (taskStopper identity)
        (Task.succeed state.processes)
        toStop
    |> flipFold (taskStopper asRecursiveKey) recursiveToStop
    |> flipFold (taskSpawner identity False) toSpawn
    |> flipFold (taskSpawner asRecursiveKey True) recursiveToSpawn
    |> Task.map
        (\newProcesses ->
            { watchers = newWatchers
            , recursiveWatchers = newRecursiveWatchers
            , processes = newProcesses
            }
        )


subToWatcher : FileSystemSub msg -> Dict String (Taggers msg) -> Dict String (Taggers msg)
subToWatcher sub taggers =
    case sub of
        Watch path _ tagger ->
            let
                key =
                    Gren.Kernel.FilePath.toString path
            in
            case Dict.get key taggers of
                Just data ->
                    Dict.set 
                        key
                        (Array.pushLast tagger data)
                        taggers

                Nothing ->
                    Dict.set key [ tagger ] taggers


attachWatcher : String -> Bool -> (WatchEvent -> Task.Task Never {}) -> Task.Task x {}
attachWatcher =
  Gren.Kernel.FileSystem.watch


type SelfMsg
    = WatchPathChange Bool String WatchEvent


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> State msg -> Task.Task Never (State msg)
onSelfMsg router (WatchPathChange recursive key event) state =
    let
        notifyApplication taggers =
            Array.foldl 
                (\tagger tasks -> 
                    tasks
                        |> Task.andThen (\{} -> Platform.sendToApp router (tagger event))
                )
                (Task.succeed {})
                taggers
                |> Task.map (\{} -> state)
    in
    if recursive then
        case Dict.get key state.recursiveWatchers of
            Just taggers ->
                notifyApplication taggers

            Nothing ->
                Task.succeed state

    else
        case Dict.get key state.watchers of
            Just taggers ->
                notifyApplication taggers

            Nothing ->
                Task.succeed state
