effect module HttpClient where { command = MyCmd } exposing
    ( Permission
    , initialize, initializeForHost
    , Request, get, post, request
    , defaultTimeout, withTimeout
    , withHeader, withDuplicatedHeader
    , Body, withEmptyBody, withStringBody, withJsonBody, withBytesBody
    , Expect, expectAnything, expectNothing, expectString, expectJson, expectBytes
    , send
    , Response
    , Error(..), errorToString
    , StreamRequest, StreamEvent(..), stream, sendChunk, startReceive, abort
    )


{-|

A module for communicating over Http.

You start by creating and modifying a `Request` type, which represents the request you'll make to a server. Once done,
you can either do a `send`, which represents the response as a `Task`, or `stream` which will allow you to perform
actions while the request is sending and while the response is coming in. A typical example of why you'd use `stream`
is to show a progress bar to the user, or decode the response incrementally as opposed to all at once.

See [examples/http-client](https://github.com/gren-lang/node/tree/main/examples/http-client) for a working example.

## Initialization

Code that wishes to perform http requests require a permission to do so. Make sure you only grant this permission
to code that you trust.

@docs Permission, initialize, initializeForHost

## Request config

Before sending something over http, you need to configure your request type.

@docs Request, get, post, request

## Timeouts

A timeout represents how long you're willing to wait before giving up on receiving
a response from the server. Servers might not respond for any number of reasons, like bugs or huge amounts of traffic,
so it can be a good idea to return an error to the user instead of waiting "forever" for a response.

@docs defaultTimeout, withTimeout

## Headers

Every http request can have arbitrary metadata attached, called headers. Headers allow you to attach things like
authorization information, how the body is encoded or the name of the client making the request.

@docs withHeader, withDuplicatedHeader

## Request body

The request body is the actual data that you wish to send to a server.

@docs Body, withEmptyBody, withStringBody, withJsonBody, withBytesBody

## Expected response body

Once a request has been sent, you usually get a response. The `Expect` type represents
what we expect the response body to be.

@docs Expect, expectAnything, expectNothing, expectString, expectJson, expectBytes

## Send

Once your `Response` is configured, you'll want to actually send the request.

@docs send

@docs Response

## Errors

@docs Error, errorToString

## Streaming

Streaming is the more advanced way to perform a http request. This requires that you follow the Elm
architecture, as you'll receive messages for every chunk of data sent and received. The benefit of this
extra complexity, is that you can perform actions while the request is being performed.

@docs StreamRequest, StreamEvent, stream, sendChunk, startReceive, abort

-}


import Dict exposing (Dict)
import Init
import Internal.Init
import Json.Encode as Json
import Json.Decode
import Bytes exposing (Bytes)
import Task exposing (Task)
import Platform
import Gren.Kernel.HttpClient


{-| A value that represents a permission to perform http requests.

Only code you trust should be granted permission.
-}
type Permission
    = AnyPermission
    | SpecificPermission String


{-| Call this during application initialization to get the permission to perform any kind of HTTP request.
-}
initialize : Init.Task Permission
initialize =
    Task.succeed AnyPermission
        |> Internal.Init.Task


{-| This will return a host-specific permission. Code that has this permission value, will only
be able to contact a specific host.
-}
initializeForHost : String -> Init.Task Permission
initializeForHost host =
    Task.succeed (SpecificPermission host)
        |> Internal.Init.Task


-- REQUEST CONFIG


{-| Represents the request to be made. Use [get](#get), [post](#post) or [request](#request) to initialize
this value, then customize it using the following `with` functions.
-}
type alias Request a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , body : Body
    , expect : Expect a
    , timeout : Int
    }


{-| Initializes the configuration for a simple GET request to the given url.
-}
get : String -> Request {}
get url =
    request "GET" url


{-| Initializes the configuration for a simple POST request to the given url.
-}
post : String -> Request {}
post url =
    request "POST" url


{-| Initializes a request configuration with the given method and url.
-}
request : String -> String -> Request {}
request method url =
    { method = method
    , url = url
    , headers = Dict.empty
    , body = BodyEmpty
    , expect = ExpectAnything
    , timeout = defaultTimeout
    }


{-| This is the default timeout value. It is set to 10 seconds.
If you don't use [withTimeout](#withTimeout) to set a timeout specifically, the
request you make will have a timeout set to this value.
-}
defaultTimeout : Int
defaultTimeout =
    -- 10 seconds
    10 * 1000


{-| Let's you specify a timeout, in milliseconds, for a request.
If the server doesn't respond to your request within the given timeout, the request
will fail with a Timeout [Error](#Error).
-}
withTimeout : Int -> Request a -> Request a
withTimeout ms req =
    if ms < 0 then
        req

    else
        { req | timeout = ms }


{-| Http requests has metadata in the form of headers. A header is a key-value pair of strings
that says something about the request. Like the length of the body, authentication information,
name of the client making the request, etc.
-}
withHeader : String -> String -> Request a -> Request a
withHeader key value req =
    { req
        | headers = Dict.insert key [value] req.headers
    }


{-| Header keys doesn't have to be unique. You're allowed to send the same kind of header
multiple times, like sending multiple cookies. The behaviour of [withHeader](#withHeader) will
replace the value of an already set header. This function will not.
-}
withDuplicatedHeader : String -> String -> Request a -> Request a
withDuplicatedHeader key value req =
    { req
        | headers = Dict.update 
            key 
            (Maybe.map (Array.pushLast value) >> Maybe.withDefault [value] >> Just)
            req.headers
    }


-- BODY


{-| The body represents the main data that you will send in the http request.
-}
type Body
    = BodyEmpty
    | BodyString String
    | BodyBytes Bytes


bodyTypeAsString : Body -> String
bodyTypeAsString body =
    case body of
        BodyEmpty ->
            "EMPTY"

        BodyString _ ->
            "STRING"

        BodyBytes _ ->
            "BYTES"


{-| Removes the body from the Request. You normally don't have to use this function,
as an empty body is the default.

If the "Content-Type" header is set, this function will remove it.
-}
withEmptyBody : Request a -> Request a
withEmptyBody req = 
    { req
        | headers = Dict.remove "Content-Type" req.headers
        , body = BodyEmpty
    }


{-| Sets the given string as the request body. You need to provide a mime type to
describe what the string contains. This mime type will be set as the "Content-Type"
header, potentially overwriting the header if it has already been set.
-}
withStringBody : String -> String -> Request a -> Request a
withStringBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyString value
    }


{-| Sets the provided Json value the request body. A "Content-Type" header will be
attached to the request with a value of "application/json", potentially overwriting
the header if it has already been set.
-}
withJsonBody : Json.Value -> Request a -> Request a
withJsonBody value req = 
    withStringBody "application/json" (Json.encode 0 value) req


{-| Sets the provided Bytes value as the request body. You need to provide a mime type to
desribe what the bytes represent. This mime type will be set as the "Content-Type" header,
potentially overwriting the header if it has already been set.
-}
withBytesBody : String -> Bytes -> Request a -> Request a
withBytesBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyBytes value
    }


-- EXPECT


{-| This describes what you expect the server will respond with when it receives your request.
-}
type Expect a
    = ExpectNothing
    | ExpectAnything
    | ExpectString
    | ExpectJson (Json.Decode.Decoder a)
    | ExpectBytes


expectTypeAsString : Expect a -> String
expectTypeAsString expect =
    case expect of
        ExpectNothing ->
            "NOTHING"

        ExpectAnything ->
            "ANYTHING"

        ExpectString ->
            "STRING"

        ExpectJson _ ->
            "JSON"

        ExpectBytes ->
            "BYTES"


{-| Use this when you you don't really care what the server responds with. Anything is fine.
Actually, this is the default value so you probably don't need to use this at all.
-}
expectAnything : Request a -> Request {}
expectAnything req =
    -- Need to create a new record for type checking to pass
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectAnything
    , timeout = req.timeout
    }


{-| Expect _exactly_ nothing. Use this when you want a request to fail if the server responds with
anything at all.
-}
expectNothing : Request a -> Request {}
expectNothing req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectNothing
    , timeout = req.timeout
    }


{-| Use this when you expect the server to respond with a string.
-}
expectString : Request a -> Request String
expectString req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectString
    , timeout = req.timeout
    }


{-| Use this when you expect a Json response. The request will fail if the provided decoder fails.
-}
expectJson : Json.Decode.Decoder a -> Request x -> Request a
expectJson decoder req = 
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectJson decoder
    , timeout = req.timeout
    }


{-| Use this when you want to treat the response as bytes. This will likely never fail, as anything
can be interpreted as bytes.
-}
expectBytes : Request a -> Request Bytes
expectBytes req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectBytes
    , timeout = req.timeout
    }


-- SIMPLE SEND


{-| Send a request. The task will either complete with a successful [Response](#Response), or an [Error](#Error).
-}
send
    : Permission 
    -> Request a
    -> Task Error (Response a)
send permission config =
    Gren.Kernel.HttpClient.request (kernelRequestConfig permission config)


type alias KernelRequestConfig a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , bodyType : String
    , body : Body
    , expectType : String
    , expect : Expect a
    , timeout : Int
    }


kernelRequestConfig : Permission -> Request a -> KernelRequestConfig a
kernelRequestConfig permission config =
    let
        actualUrl =
            case permission of
                AnyPermission ->
                    config.url

                SpecificPermission prefix ->
                    prefix ++ config.url
    in
    { method = config.method
    , url = actualUrl
    , headers = config.headers
    , bodyType = bodyTypeAsString config.body
    , body = config.body
    , expectType = expectTypeAsString config.expect
    , expect = config.expect
    , timeout = config.timeout
    }


-- RESPONSE


{-| The response from the server.

* statusCode: A numerical value that gives an indication of how the request went. 200 means OK.
* statusText: A human readable interpretation of the status code.
* headers: The headers returned by the server.
* data: The data returned by the server. The type depends on the [Expect](#Expect) value you set on the request.
-}
type alias Response data =
    { statusCode : Int
    , statusText : String
    , headers : Dict String (Array String)
    , data : data
    }


-- ERRORS


{-| A Http request can fail in a number of ways.

* BadUrl: Something is wrong with the URL you provided.
* BadHeaders: The request headers are invalid. Make sure you only use characters in the latin-1 character set.
* BadStatus: The status code indicates that the response didn't go well. The [Response](#Response) is attached, with a string-encoded data.
* Timeout: The request timed out. The server didn't respond as quickly as you expected it would.
* UnknownError: We don't know what went wrong. You should probably report this if you see it in the wild.
-}
type Error 
    = BadUrl String
    | BadHeaders
    | BadStatus (Response String)
    | Timeout
    | UnknownError String


{-|
-}
errorToString : Error -> String
errorToString err =
    case err of
        Timeout ->
            "Timeout"

        BadUrl url ->
            "Bad URL: " ++ url

        BadHeaders ->
            "Bad headers: one or more of your headers contains invalid characters."

        BadStatus res ->
            "Bad status: " ++ String.fromInt res.statusCode

        UnknownError debugStr ->
            "Unknown error: " ++ debugStr


-- STREAM


{-|
-}
type StreamRequest =
    StreamRequest Int


{-|
-}
type StreamEvent
    = SentChunk StreamRequest
    | ReceivedChunk StreamRequest (Response Bytes)
    | Error Error
    | Aborted
    | Done


{-|
-}
stream : Permission -> (StreamEvent -> msg) -> Request Bytes -> Cmd msg
stream permission toMsg config =
    command <| Start toMsg <| kernelRequestConfig permission config


{-|
-}
sendChunk : StreamRequest -> Bytes -> Cmd msg
sendChunk req bytes =
    command <| SendChunk bytes req


{-|
-}
startReceive : StreamRequest -> Cmd msg
startReceive req =
    command <| StartReceive req


{-|
-}
abort : StreamRequest -> Cmd a
abort req =
    command <| Abort req


-- COMMANDS


type MyCmd msg
    = Start (StreamEvent -> msg) (KernelRequestConfig Bytes)
    | SendChunk Bytes StreamRequest
    | StartReceive StreamRequest
    | Abort StreamRequest


cmdMap : (a -> b) -> MyCmd a -> MyCmd b
cmdMap func cmd =
    case cmd of
        Start toMsg req ->
            Start (toMsg >> func) req

        SendChunk bytes req ->
            SendChunk bytes req
        
        StartReceive req ->
            StartReceive req

        Abort req ->
            Abort req


type alias RequestsState msg =
    { nextId : Int 
    , msgHandlers : Dict Int { toMsg : (StreamEvent -> msg), kernelRequest : KernelRequest }
    }


type KernelRequest = 
    -- Actual implementation provided by kernel code
    KernelRequest


init : Task Never (RequestsState msg)
init =
  Task.succeed
    { nextId = 0
    , msgHandlers = Dict.empty
    }


onEffects : Platform.Router msg SelfMsg -> Array (MyCmd msg) -> RequestsState msg -> Task Never (RequestsState msg)
onEffects router commands state =
  case Array.popFirst commands of
    Nothing ->
      Task.succeed state

    Just { first, rest } ->
        case first of
            Start toMsg config ->
                let
                    streamingReq =
                        StreamRequest state.nextId
                in
                Gren.Kernel.HttpClient.stream 
                    (Platform.sendToSelf router << Cleanup) 
                    (Platform.sendToApp router << toMsg) 
                    streamingReq 
                    config
                    |> Task.map 
                        (\kernelRequest -> 
                            { state 
                                | nextId = state.nextId + 1
                                , msgHandlers = 
                                    Dict.insert 
                                        state.nextId
                                        { toMsg = toMsg
                                        , kernelRequest = kernelRequest
                                        }
                                        state.msgHandlers
                            }
                        )
                    |> Task.andThen (\updatedState -> onEffects router rest updatedState)

            SendChunk bytes ((StreamRequest reqId) as req) ->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.sendChunk 
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            bytes
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state
            
            StartReceive ((StreamRequest reqId) as req)->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.startReceive
                            (Platform.sendToSelf router << Cleanup)
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state

            Abort (StreamRequest reqId)->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.abort msgHandler.kernelRequest
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state
                

type SelfMsg
    = Cleanup StreamRequest


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> RequestsState msg -> Task Never (RequestsState msg)
onSelfMsg _ event state =
    case event of
        Cleanup (StreamRequest reqId) ->
            Task.succeed 
                { state | msgHandlers = Dict.remove reqId state.msgHandlers }
