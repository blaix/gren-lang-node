effect module HttpClient where { command = MyCmd } exposing (..)

import Dict exposing (Dict)
import Init
import Internal.Init
import Json.Encode as Json
import Json.Decode
import Bytes exposing (Bytes)
import Task exposing (Task)
import Platform
import Gren.Kernel.HttpClient


type Permission =
    Permission


initialize : Init.Task Permission
initialize =
    Task.succeed Permission
        |> Internal.Init.Task


-- REQUEST CONFIG


type alias Request a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , body : Body
    , expect : Expect a
    , timeout : Int
    }


get : String -> Request {}
get url =
    request "GET" url


post : String -> Request {}
post url =
    request "POST" url


request : String -> String -> Request {}
request method url =
    { method = method
    , url = url
    , headers = Dict.empty
    , body = BodyEmpty
    , expect = ExpectAnything
    , timeout = defaultTimeout
    }


defaultTimeout : Int
defaultTimeout =
    -- 10 seconds
    10 * 1000


withHeader : String -> String -> Request a -> Request a
withHeader key value req =
    { req
        | headers = Dict.insert key [value] req.headers
    }


withHeaderAppended : String -> String -> Request a -> Request a
withHeaderAppended key value req =
    { req
        | headers = Dict.update 
            key 
            (Maybe.map (Array.pushLast value) >> Maybe.withDefault [value] >> Just)
            req.headers
    }


withEmptyBody : String -> Request a -> Request a
withEmptyBody value req = 
    { req
        | headers = Dict.remove "Content-Type" req.headers
        , body = BodyEmpty
    }


withStringBody : String -> String -> Request a -> Request a
withStringBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyString value
    }


withJsonBody : Json.Value -> Request a -> Request a
withJsonBody value req = 
    withStringBody "application/json" (Json.encode 0 value) req


withBytesBody : String -> Bytes -> Request a -> Request a
withBytesBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyBytes value
    }


expectAnything : Request a -> Request {}
expectAnything req =
    -- Need to create a new record for type checking to pass
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectAnything
    , timeout = req.timeout
    }


expectNothing : Request a -> Request {}
expectNothing req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectNothing
    , timeout = req.timeout
    }


expectString : Request a -> Request String
expectString req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectString
    , timeout = req.timeout
    }


expectJson : Json.Decode.Decoder a -> Request x -> Request a
expectJson decoder req = 
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectJson decoder
    , timeout = req.timeout
    }


expectBytes : Request a -> Request Bytes
expectBytes req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectBytes
    , timeout = req.timeout
    }


withTimeout : Int -> Request a -> Request a
withTimeout ms req =
    if ms < 0 then
        req

    else
        { req | timeout = ms }


-- BODY


type Body
    = BodyEmpty
    | BodyString String
    | BodyBytes Bytes


bodyTypeAsString : Body -> String
bodyTypeAsString body =
    case body of
        BodyEmpty ->
            "EMPTY"

        BodyString _ ->
            "STRING"

        BodyBytes _ ->
            "BYTES"


-- EXPECT


type Expect a
    = ExpectNothing
    | ExpectAnything
    | ExpectString
    | ExpectJson (Json.Decode.Decoder a)
    | ExpectBytes


expectTypeAsString : Expect a -> String
expectTypeAsString expect =
    case expect of
        ExpectNothing ->
            "NOTHING"

        ExpectAnything ->
            "ANYTHING"

        ExpectString ->
            "STRING"

        ExpectJson _ ->
            "JSON"

        ExpectBytes ->
            "BYTES"


-- RESPONSE


type alias Response a =
    { statusCode : Int
    , statusText : String
    , headers : Dict String (Array String)
    , data : a
    }


-- ERRORS


type Error 
    = Timeout
    | BadUrl String
    | BadStatus (Response String)
    | UnknownError String


errorToString : Error -> String
errorToString err =
    case err of
        Timeout ->
            "Timeout"

        BadUrl url ->
            "Bad URL: " ++ url

        BadStatus res ->
            "Bad status: " ++ String.fromInt res.statusCode

        UnknownError debugStr ->
            "Unknown error: " ++ debugStr


-- SIMPLE SEND


send
    : Permission 
    -> Request a
    -> Task Error (Response a)
send _ config =
    Gren.Kernel.HttpClient.request <| kernelRequestConfig config


type alias KernelRequestConfig a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , bodyType : String
    , body : Body
    , expectType : String
    , expect : Expect a
    , timeout : Int
    }


kernelRequestConfig : Request a -> KernelRequestConfig a
kernelRequestConfig config =
    { method = config.method
    , url = config.url
    , headers = config.headers
    , bodyType = bodyTypeAsString config.body
    , body = config.body
    , expectType = expectTypeAsString config.expect
    , expect = config.expect
    , timeout = config.timeout
    }


-- STREAM


type StreamingRequest =
    StreamingRequest Int


type Progress
    = SentChunk StreamingRequest
    | ReceivedChunk StreamingRequest Bytes
    | Error Error
    | Done


stream : Permission -> (Progress -> msg) -> Request Bytes -> Cmd msg
stream _ toMsg config =
    command <| Start toMsg <| kernelRequestConfig config


sendChunk : StreamingRequest -> Bytes -> Cmd msg
sendChunk req bytes =
    command <| SendChunk bytes req

startReceive : StreamingRequest -> Cmd msg
startReceive req =
    command <| StartReceive req


abort : StreamingRequest -> Cmd a
abort req =
    command <| Abort req


-- COMMANDS


type MyCmd msg
    = Start (Progress -> msg) (KernelRequestConfig Bytes)
    | SendChunk Bytes StreamingRequest
    | StartReceive StreamingRequest
    | Abort StreamingRequest


cmdMap : (a -> b) -> MyCmd a -> MyCmd b
cmdMap func cmd =
    case cmd of
        Start toMsg req ->
            Start (toMsg >> func) req

        SendChunk bytes req ->
            SendChunk bytes req
        
        StartReceive req ->
            StartReceive req

        Abort req ->
            Abort req


type alias RequestsState msg =
    { nextId : Int 
    , msgHandlers : Dict Int { toMsg : (Progress -> msg), kernelRequest : KernelRequest }
    }


type KernelRequest = 
    -- Actual implementation provided by kernel code
    KernelRequest


init : Task Never (RequestsState msg)
init =
  Task.succeed
    { nextId = 0
    , msgHandlers = Dict.empty
    }


onEffects : Platform.Router msg SelfMsg -> Array (MyCmd msg) -> RequestsState msg -> Task Never (RequestsState msg)
onEffects router commands state =
  case Array.popFirst commands of
    Nothing ->
      Task.succeed state

    Just { first, rest } ->
        case first of
            Start toMsg config ->
                let
                    streamingReq =
                        StreamingRequest state.nextId
                in
                Gren.Kernel.HttpClient.stream 
                    (Platform.sendToSelf router << Cleanup) 
                    (Platform.sendToApp router << toMsg) 
                    streamingReq 
                    config
                    |> Task.map 
                        (\kernelRequest -> 
                            { state 
                                | nextId = state.nextId + 1
                                , msgHandlers = 
                                    Dict.insert 
                                        state.nextId
                                        { toMsg = toMsg
                                        , kernelRequest = kernelRequest
                                        }
                                        state.msgHandlers
                            }
                        )
                    |> Task.andThen (\updatedState -> onEffects router rest updatedState)

            SendChunk bytes ((StreamingRequest reqId) as req) ->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.sendChunk 
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            bytes
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state
            
            StartReceive ((StreamingRequest reqId) as req)->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.startReceive
                            (Platform.sendToSelf router << Cleanup)
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state

            Abort req ->
                Task.andThen
                    (\_ -> onEffects router rest state)
                    (Task.succeed state)
                

type SelfMsg
    = Cleanup StreamingRequest


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> RequestsState msg -> Task Never (RequestsState msg)
onSelfMsg _ event state =
    case event of
        Cleanup (StreamingRequest reqId) ->
            Task.succeed 
                { state | msgHandlers = Dict.remove reqId state.msgHandlers }
