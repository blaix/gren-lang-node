effect module Terminal where { command = TerminalCmd, subscription = TerminalSub } exposing
    ( Permission
    , Configuration
    , Size
    , initialize
    --
    , setStdInRawMode
    --
    , onResize
    )


{-| This lets you interact with the user's terminal, if an interactive
terminal is connected to this application.

## Initialization

@docs Permission, Configuration, Size, initialize

## Commands

@docs setStdInRawMode

## Subscriptions

@docs onResize
-}


import Task exposing (Task)
import Process
import Node.Program as Program
import Gren.Kernel.Terminal
import Internal.AppInitTask exposing (AppInitTask(..))


{-| The permission for performing commands specified in this module.
-}
type Permission
    = Permission


{-| The configuration of the attached interactive terminal.
-}
type alias Configuration =
    { permission : Permission
    , colorDepth : Int
    , columns : Int
    , rows : Int
    }


{-| Size of a terminal. Handy to know for drawing a text-based UI.
-}
type alias Size =
    { columns : Int
    , rows : Int
    }


-- INIT


{-| Initializes the `Terminal` subsystem.

`Nothing` is returned if this program isn't connected to an interactive terminal, which
can happen in CI-setups or when used as part of a unix pipe.
-}
initialize : Program.AppInitTask (Maybe Configuration)
initialize =
    Gren.Kernel.Terminal.init
        |> Task.map (\raw ->
            if raw.isTTY then
                Just
                    { permission = Permission
                    , colorDepth = raw.colorDepth
                    , columns = raw.columns
                    , rows = raw.rows
                    }

            else
                Nothing
        )
        |> AppInitTask


-- COMMANDS


type TerminalCmd a
    = SetStdInRawMode Bool


cmdMap : (a -> b) -> TerminalCmd a -> TerminalCmd b
cmdMap _ cmd =
    case cmd of
        SetStdInRawMode toggle ->
            SetStdInRawMode toggle


{-| In it's default mode, `stdin` only sends data when the user hits the enter key.

If you switch over to raw mode, every keypress will be sent over the stream, and special
combinations like `Ctrl-C` will no longer trigger the kill signal.

Enable this when you need full control over how input is handled.
-}
setStdInRawMode : Permission -> Bool -> Cmd a
setStdInRawMode _ toggle =
    command (SetStdInRawMode toggle)


-- SUBSCRIPTIONS


type TerminalSub msg
    = OnResize (Size -> msg)


subMap : (a -> b) -> TerminalSub a -> TerminalSub b
subMap mapFn sub =
    case sub of
        OnResize msgMap ->
            OnResize (mapFn << msgMap)


{-| A subscription that triggers every time the size of the terminal changes.
-}
onResize : Permission -> (Size -> msg) -> Sub msg
onResize _ toMsg =
    subscription (OnResize toMsg)


-- LOOP


type alias State msg =
    { taggers : Array (Size -> msg)
    , maybeProcessId : Maybe Process.Id
    }


init : Task Never (State msg)
init =
    Task.succeed
        { taggers = []
        , maybeProcessId = Nothing
        }


onEffects
    : Platform.Router msg Event
    -> Array (TerminalCmd msg)
    -> Array (TerminalSub msg)
    -> State msg
    -> Task Never (State msg)
onEffects router commands subs state =
    let
        newTaggers =
            Array.foldl extractTagger [] subs

        extractTagger (OnResize tagger) acc =
            Array.pushLast tagger acc

        subscriptionTask =
            if Array.length newTaggers > 0 then
                case state.maybeProcessId of
                    Just pid ->
                        Task.succeed <| Just pid

                    Nothing ->
                        Gren.Kernel.Terminal.attachListener (\data -> Platform.sendToSelf router (SelfOnResize data))
                            |> Process.spawn
                            |> Task.map Just


            else
                case state.maybeProcessId of
                    Just pid ->
                        Process.kill pid
                            |> Task.map (\_ -> Nothing)

                    Nothing ->
                        Task.succeed Nothing

        commandTasks =
            Array.foldl
                (\(SetStdInRawMode toggle) tasks ->
                    Task.andThen (\_ -> Platform.sendToSelf router (SelfToggleStdInRawMode toggle)) tasks
                )
                (Task.succeed {})
                commands
    in
        commandTasks
            |> Task.andThen (\_ -> subscriptionTask)
            |> Task.andThen (\maybeProcessId ->
                Task.succeed
                    { taggers = newTaggers
                    , maybeProcessId = maybeProcessId
                    }
                )


type Event
    = SelfToggleStdInRawMode Bool
    | SelfOnResize Size


onSelfMsg : Platform.Router msg Event -> Event -> State msg -> Task Never (State msg)
onSelfMsg router event state =
    case event of
        SelfToggleStdInRawMode toggle ->
            let
                _ =
                    Gren.Kernel.Terminal.setStdInRawMode toggle
            in
                Task.succeed state

        SelfOnResize newSize ->
            state.taggers
                |> Array.map (\tagger -> tagger newSize)
                |> Array.foldl
                    (\msg tasks ->
                        Task.andThen (\{} -> Platform.sendToApp router msg) tasks
                    )
                    (Task.succeed {})
                |> Task.andThen (\_ -> Task.succeed state)
