module Node exposing
    ( Configuration
    , initialize
    --
    , Platform(..)
    , CpuArchitecture(..)
    , getEnvironmentVariables
    --
    , exit
    , exitWithCode
    , setExitCode
    )

{-| This module allows you to start your application with access to application arguments,
environment variables and the standard input and output streams.

To learn how to use this module's `initialize` function, take a closer look at the `Node.Program` module.

## Initialization

@docs Configuration, initialize

## Info

@docs Platform, CpuArchitecture, getEnvironmentVariables

## Exit

@docs exit, exitWithCode, setExitCode
-}

import Dict exposing ( Dict )
import Gren.Kernel.Node
import Task exposing (Task)
import Node.Program as Program
import Internal.Stream as IStream
import Init
import Internal.Init


type alias RawConfiguration =
    { platform : String
    , arch : String
    , args : Array String
    , stdout : IStream.RawStream
    , stderr : IStream.RawStream
    , stdin : IStream.RawStream
    }


{-| Contains information about the context your application was initiated.

* `platform` and `cpuArchitecture` tells you something about the operating system and machine your application is running on.
* `args` is an `Array` of the arguments passed to your application.
* `stdout`, `stderr` and `stdin` are streams you can use to communicate with the outside world. Take a closer look at the `Stream` module for more information.

-}
type alias Configuration =
    { platform : Platform
    , cpuArchitecture : CpuArchitecture
    , args : Array String
    , stdout : IStream.Stream
    , stderr : IStream.Stream
    , stdin : IStream.Stream
    }


{-| Initialize a NodeJS application. In return you're granted the `Configuration` record, which contains useful context.
-}
initialize : Init.Task Configuration
initialize =
    Gren.Kernel.Node.init
        |> Task.map
                (\raw ->
                    { platform = platformFromString raw.platform
                    , cpuArchitecture = archFromString raw.arch
                    , args = raw.args
                    , stdout = IStream.Stream 0 raw.stdout
                    , stderr = IStream.Stream 1 raw.stderr
                    , stdin = IStream.Stream 2 raw.stdin
                    }
                )
        |> Internal.Init.Task


-- PLATFORM


{-| The platform, or operating system, that your application is running on.
-}
type Platform
    = Win32
    | Darwin
    | Linux
    | FreeBSD
    | OpenBSD
    | SunOS
    | Aix
    | UnknownPlatform


platformFromString : String -> Platform
platformFromString platform =
    case String.toLower platform of
        "win32" ->
            Win32

        "darwin" ->
            Darwin

        "linux" ->
            Linux

        "freebsd" ->
            FreeBSD

        "openbsd" ->
            OpenBSD

        "sunos" ->
            SunOS

        "aix" ->
            Aix

        _ ->
            UnknownPlatform


-- ARCH


{-| The CPU architecture your application is running on.
-}
type CpuArchitecture
    = Arm
    | Arm64
    | IA32
    | Mips
    | Mipsel
    | PPC
    | PPC64
    | S390
    | S390x
    | X64
    | UnknownArchitecture


archFromString : String -> CpuArchitecture
archFromString arch =
    case String.toLower arch of
        "arm" ->
            Arm

        "arm64" ->
            Arm64

        "ia32" ->
            IA32

        "mips" ->
            Mips

        "mipsel" ->
            Mipsel

        "ppc" ->
            PPC

        "ppc64" ->
            PPC64

        "s390" ->
            S390

        "s390x" ->
            S390x

        "x64" ->
            X64

        _ ->
            UnknownArchitecture


-- TASKS


{-| Get a `Dict` of environment variables.
-}
getEnvironmentVariables : Task Never (Dict String String)
getEnvironmentVariables =
    Gren.Kernel.Node.getEnvironmentVariables


{-| Terminate the program immediatly. It will not wait for tasks like http calls
or file system writes, so only use this if you've reached a state where it makes
no sense to continue.
-}
exit : Cmd msg
exit =
    Gren.Kernel.Node.exit
        |> Task.perform never


{-| Terminate the program immediatly. It will not wait for tasks like http calls
or file system writes, so only use this if you've reached a state where it makes
no sense to continue.

The exit code can be read by other processes on your system. Any value other than
0 is considered an error.
-}
exitWithCode : Int -> Cmd msg
exitWithCode code =
    Gren.Kernel.Node.exitWithCode code
        |> Task.perform never


{-| Set the error code that the program will return once it finishes.

Note: This will not terminate your program, so things like http calls
or writes to the filesystem will be allowed to complete. However,
the program will only exit once there are no ongoing tasks.
-}
setExitCode : Int -> Cmd msg
setExitCode code =
    Gren.Kernel.Node.setExitCode code
        |> Task.perform never
