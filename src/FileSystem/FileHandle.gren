module FileSystem.FileHandle exposing
    ( FileHandle
    , ReadableFileHandle
    , WriteableFileHandle
    , ReadWriteableFileHandle
    , ReadPermission
    , WritePermission
    , makeReadOnly
    , makeWriteOnly
    --
    , openForRead
    , OpenForWriteBehaviour (..)
    , openForWrite
    , openForReadAndWrite
    , close
    --
    , read
    , readFromOffset
    --
    , write
    , writeFromOffset
    --
    , changeAccess
    , changeOwner
    , changeTimes
    , sync
    , syncData
    , metadata
    , truncate
    )


{-| This module provides access to the file system. It allows you to read and write files or directories.

## File open/close

@docs FileHandle, ReadableFileHandle, WriteableFileHandle, ReadWriteableFileHandle, ReadPermission, WritePermission, makeReadOnly, makeWriteOnly, openForRead, OpenForWriteBehaviour, openForWrite, openForReadAndWrite, close

## Read from file

@docs read, readFromOffset

## Write to file

@docs write, writeFromOffset

## Temp

@docs changeAccess, changeOwner, changeTimes, sync, syncData, metadata, truncate

-}


import Gren.Kernel.FileSystem
import Bytes exposing (Bytes)
import Task exposing (Task)
import FileSystem.Path exposing (Path)
import FileSystem exposing (Permission, AccessError, UnknownFileSystemError)
import Init
import Internal.Init
import Time


{-| A file handle is used to perform operations on a file, like reading and writing.

Having a file handle gives you access to perform certain operations, so make sure you
only pass a file handle to code you can trust.

The `FileHandle` type also contains the read and write access permissions as part of its
type.
-}
type FileHandle readAccess writeAccess
    -- Note: Actual implementation in kernel code
    = FileHandle


{-| A type that represents the permission to read from a file.
-}
type ReadPermission = ReadPermission


{-| A type that represents the permission to write to a file.
-}
type WritePermission = WritePermission


{-| A `FileHandle` that can be used in read operations.
-}
type alias ReadableFileHandle a = FileHandle ReadPermission a


{-| A `FileHandle` that can be used in write operations.
-}
type alias WriteableFileHandle a = FileHandle a WritePermission


{-| A `FileHandle` that can be used for both read and write operations.
-}
type alias ReadWriteableFileHandle = FileHandle ReadPermission WritePermission


{-| This lets you downgrade a `ReadWriteableFileHandle` to a `FileHandle` that only has read permission.

Comes in handy when you want full access to a file in some parts of your code, but limited access in other parts
of your code.
-}
makeReadOnly : ReadWriteableFileHandle -> FileHandle ReadPermission Never
makeReadOnly =
    Gren.Kernel.FileSystem.coerce


{-| This let's you downgrade a `ReadWriteableFileHandle` to a `FileHandle` that only has write permission.

Comes in handy when you want full access to a file in some parts of your code, but limited access in other parts
of your code.
-}
makeWriteOnly : ReadWriteableFileHandle -> FileHandle Never WritePermission
makeWriteOnly =
    Gren.Kernel.FileSystem.coerce


-- OPEN


{-| Open the file at the provided path with read permissions.
-}
openForRead : Permission -> Path -> Task AccessError (FileHandle ReadPermission Never)
openForRead _ path =
    openImpl "r" path


{-| There are several ways to open a file for writing.

* `EnsureEmpty` will create an empty file if it doesn't exist, or remove all contents of a file if it does exist.
* `ExpectExisting` will fail the task if it doesn't exist.
* `ExpectNotExisting` will fail the task if the file does exist.
-}
type OpenForWriteBehaviour
    = EnsureEmpty
    | ExpectExisting
    | ExpectNotExisting


{-| Open a file at the provided path with write permissions.
-}
openForWrite : Permission -> OpenForWriteBehaviour -> Path -> Task AccessError (FileHandle Never WritePermission)
openForWrite _ behaviour path =
    let
        access =
            case behaviour of
                EnsureEmpty -> "w"
                ExpectExisting -> "r+"
                ExpectNotExisting -> "wx"
    in
    openImpl access path


{-| Open a file for at the provided path with both read and write permissions.
-}
openForReadAndWrite : Permission -> OpenForWriteBehaviour -> Path -> Task AccessError ReadWriteableFileHandle
openForReadAndWrite _ behaviour path =
    let
        access =
            case behaviour of
                EnsureEmpty -> "w+"
                ExpectExisting -> "r+"
                ExpectNotExisting -> "wx+"
    in
    openImpl access path


openImpl : String -> Path -> Task AccessError (FileHandle a b)
openImpl =
    Gren.Kernel.FileSystem.open


-- CLOSE

{-| Close a file. All operations performed against the given `FileHandle` will fail.
-}
close : FileHandle a b -> Task UnknownFileSystemError {}
close =
    Gren.Kernel.FileSystem.close


-- READING


{-| Read all bytes in a file.
-}
read : ReadableFileHandle a -> Task UnknownFileSystemError Bytes
read fh =
    readFromOffset fh { offset = 0, length = -1 }


{-| Read `length` number of bytes from a file, starting at `offset` bytes.
-}
readFromOffset : ReadableFileHandle a -> { offset : Int, length : Int } -> Task UnknownFileSystemError Bytes
readFromOffset =
    Gren.Kernel.FileSystem.readFromOffset


-- WRITING


{-| Write the provided bytes into the file. If the file is not empty, bytes will be overwritten.
-}
write : WriteableFileHandle a -> Bytes -> Task UnknownFileSystemError (WriteableFileHandle a)
write fh bytes =
    writeFromOffset fh 0 bytes


{-| Write bytes into a specific location of a file.
-}
writeFromOffset : WriteableFileHandle a -> Int -> Bytes -> Task UnknownFileSystemError (WriteableFileHandle a)
writeFromOffset =
    Gren.Kernel.FileSystem.writeFromOffset


-- OTHER INFORMATION


type AccessMode
    = Read
    | Write
    | Execute


changeAccess 
    : { owner : Array AccessMode
      , group : Array AccessMode
      , others : Array AccessMode
      }
    -> WriteableFileHandle a
    -> Task UnknownFileSystemError (WriteableFileHandle a)
changeAccess modes fh =
    let
        mode =
            (accessModeInt modes.owner * 100)
            + (accessModeInt modes.group * 10)
            + accessModeInt modes.others
    in
    Gren.Kernel.FileSystem.fchmod mode fh


accessModeInt : Array AccessMode -> Int
accessModeInt values =
    let
        numberFor num a =
            if Array.member a values then
                num

            else
                0
    in
    numberFor 4 Read + numberFor 2 Write + numberFor 1 Execute


changeOwner : { userID : Int, groupID : Int } -> WriteableFileHandle a -> Task UnknownFileSystemError (WriteableFileHandle a)
changeOwner =
    Gren.Kernel.FileSystem.fchown


sync : WriteableFileHandle a -> Task UnknownFileSystemError (WriteableFileHandle a)
sync =
    Gren.Kernel.FileSystem.fsync


syncData : WriteableFileHandle a -> Task UnknownFileSystemError (WriteableFileHandle a)
syncData =
    Gren.Kernel.FileSystem.fdatasync


type alias FileMetadata =
    {}


metadata : ReadableFileHandle a -> Task UnknownFileSystemError (ReadableFileHandle FileMetadata)
metadata =
    Gren.Kernel.FileSystem.fstat


truncate : Int -> WriteableFileHandle a -> Task UnknownFileSystemError (WriteableFileHandle a)
truncate =
    Gren.Kernel.FileSystem.ftruncate


changeTimes 
    : { lastAccessed : Time.Posix
      , lastModified : Time.Posix 
      }
    -> WriteableFileHandle a
    -> Task UnknownFileSystemError (WriteableFileHandle a)
changeTimes { lastAccessed, lastModified } fh =
    Gren.Kernel.FileSystem.futimes
        (Time.posixToMillis lastAccessed // 1000)
        (Time.posixToMillis lastModified // 1000)
        fh
