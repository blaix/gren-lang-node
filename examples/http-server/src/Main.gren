module Main exposing (main)

import Node
import Bytes exposing (Bytes)
import Bytes.Decode as Decode
import Dict
import Stream exposing (Stream)
import Node exposing (Environment, Program)
import HttpServer as Http exposing (ServerError(..), Method(..), Request)
import HttpServer.Response as Response exposing (Response)
import Init
import Task


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


type alias Model =
    { stdout : Stream
    , stderr : Stream
    , servers : Array Http.Server
    }


type Msg
    = CreateServersResult (Result Http.ServerError (Array Http.Server))
    | GotRequest1 Http.Request Response
    | GotRequest2 Http.Request Response


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await Http.initialize <| \serverPermission ->
        Node.startProgram
            { model =
                { stdout = env.stdout
                , stderr = env.stderr
                , servers = []
                }
            , command =
                Task.attempt CreateServersResult <|
                    Task.sequence 
                        [ Http.createServer serverPermission
                            { host = "0.0.0.0"
                            , port_ = 3000
                            }
                        , Http.createServer serverPermission
                            { host = "0.0.0.0"
                            , port_ = 3001
                            }
                        ]
            }


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    case msg of
        CreateServersResult results ->
            case results of
                Ok servers ->
                    { model = { model | servers = servers }
                    , command = Stream.sendLine model.stdout
                        "Servers started"
                    }
                Err (ServerError code message) ->
                    { model = model
                    , command = Stream.sendLine model.stderr <|
                        "Servers failed to start: " ++ code ++ "\n" ++ message
                    }
        
        GotRequest1 req res ->
            { model = model
            , command = handleRequest req res
            }

        GotRequest2 req res ->
            { model = model
            , command = handleRequest req res
            }


handleRequest : Request -> Response -> Cmd Msg
handleRequest req res =
    let
        { body, status } = case { method = req.method, path = req.url.path } of
            { method = GET, path = "/" } ->
                { body = "Welcome!"
                , status = 200
                }

            { method = GET, path = "/hello" } ->
                { body = "Hello to you too!"
                , status = 200
                }
        
            { method = POST } ->
                let
                    -- TODO: add `Request.bodyAsString` and `Request.bodyFromJson <decoder>` helpers
                    bodyStr = 
                        req.body
                            |> Decode.decode (Decode.string <| Bytes.width req.body)
                            |> Maybe.withDefault "Oops! Can't decode body."
                in
                { body = "You posted: " ++ bodyStr
                , status = 200
                }
        
            _ ->
                { body = "Not found: " ++ (Http.requestInfo req)
                , status = 404
                }
    in
    res
        |> Response.setStatus status
        |> Response.setHeader "Content-type" "text/html"
        |> Response.setHeader "X-Custom-Header" "hey there"
        |> Response.setBody ("<html>" ++ body ++ "</html>")
        |> Http.respond


subscriptions : Model -> Sub Msg
subscriptions model =
    case model.servers of
        [server1, server2] ->
            Sub.batch
                [ Http.onRequest server1 GotRequest2
                , Http.onRequest server2 GotRequest2
                ]

        _ ->
            Sub.none
