module Main exposing (main)

import Node
import Init
import Task
import HttpClient
import Stream exposing (Stream)
import Json.Encode as Json
import Json.Decode
import Dict
import Bytes exposing (Bytes)
import Bytes.Encode
import Bytes.Decode


type alias Model =
    { stdout : Stream 
    , httpPermission : HttpClient.Permission
    }


type Msg 
    = Response (Result HttpClient.Error (HttpClient.Response String))
    | JsonResponse (Result HttpClient.Error (HttpClient.Response { response : String }))
    | BytesResponse (Result HttpClient.Error (HttpClient.Response Bytes))


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = \_ -> Sub.none
        }


init : Node.Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await HttpClient.initialize <| \httpPerm ->
        Node.startProgram
            { model = 
                { stdout = env.stdout
                , httpPermission = httpPerm
                }
            , command =
                case Array.get 2 env.args of
                    Just "simple get" ->
                        HttpClient.get httpPerm 
                            { url ="http://localhost:8080/mocked-path"
                            , expect = HttpClient.expectString
                            }
                            |> Task.attempt Response
                    
                    Just "post with body" ->
                        HttpClient.post httpPerm 
                            { url ="http://localhost:8080/mocked-path"
                            , body = 
                                -- Overly complicated, but it's for testing bytes support
                                HttpClient.bytesBody "application/json" <|
                                    (Bytes.Encode.encode (Bytes.Encode.string "{ \"secret\": \"Hello, POST!\" }"))
                            , expect = HttpClient.expectJson
                                (Json.Decode.map (\s -> { response = s })
                                    (Json.Decode.field "response" Json.Decode.string)
                                )
                            }
                            |> Task.attempt JsonResponse
                    
                    Just "timeout" ->
                        HttpClient.request httpPerm 
                            { method = "GET"
                            , url = "http://localhost:8080/mocked-path"
                            , headers = Dict.empty
                            , body = HttpClient.emptyBody
                            , expect = HttpClient.expectString
                            , timeout = Just 50
                            }
                            |> Task.attempt Response
                    
                    Just "headers" ->
                        HttpClient.request httpPerm 
                            { method = "POST"
                            , url = "http://localhost:8080/mocked-path"
                            , headers = Dict.empty
                                |> Dict.insert "X-Request-ID" "12345"
                            , body = HttpClient.jsonBody <|
                                Json.object
                                    [ { key = "message", value = Json.string "Check out my headers" }]
                            , expect = HttpClient.expectJson <|
                                Json.Decode.map (\s -> { response = s })
                                    (Json.Decode.field "response" Json.Decode.string)
                            , timeout = Nothing
                            }
                            |> Task.attempt JsonResponse

                    Just "bytes" ->
                        HttpClient.request httpPerm 
                            { method = "GET"
                            , url = "http://localhost:8080/mocked-path"
                            , headers = Dict.empty
                            , body = HttpClient.emptyBody
                            , expect = HttpClient.expectBytes
                            , timeout = Nothing
                            }
                            |> Task.attempt BytesResponse
                    
                    _ ->
                        Stream.sendLine env.stdout"Invalid start argument"
            }


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    case msg of
        Response (Ok response) ->
            { model = model
            , command = Stream.sendLine model.stdout (String.fromInt response.statusCode ++ ": " ++ response.data)
            }

        Response (Err err) ->
            { model = model
            , command = Stream.sendLine model.stdout (HttpClient.errorToString err)
            }
        
        JsonResponse (Ok response) ->
            { model = model
            , command = Stream.sendLine model.stdout (String.fromInt response.statusCode ++ ": " ++ response.data.response)
            }

        JsonResponse (Err err) ->
            { model = model
            , command = Stream.sendLine model.stdout (HttpClient.errorToString err)
            }
        
        BytesResponse (Ok response) ->
            let
                decoder =
                    Bytes.Decode.map2 (\i1 i2 -> { i1 = i1, i2 = i2})
                        (Bytes.Decode.unsignedInt32 Bytes.BE)
                        (Bytes.Decode.unsignedInt32 Bytes.BE)
            in
            case Bytes.Decode.decode decoder response.data of
                Just { i1, i2 } ->
                    { model = model
                    , command = Stream.sendLine model.stdout (String.fromInt response.statusCode ++ ": " ++ String.fromInt i1 ++ " & " ++ String.fromInt i2)
                    }

                Nothing ->
                    { model = model
                    , command = Stream.sendLine model.stdout "Failed to decode byte sequence"
                    }
                    

        BytesResponse (Err err) ->
            { model = model
            , command = Stream.sendLine model.stdout (HttpClient.errorToString err)
            }
            
